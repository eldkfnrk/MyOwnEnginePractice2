#pragma once
#include "mfeEntity.h"
#include "mfeGameObject.h"
#include "mfeLayer.h"

//영화를 보면 우리는 영화를 하나의 화면으로 보지만 영화의 촬영은 한 번에 원 테이크로 처음부터 끝까지 촬영하는 것이 아닌 한 테이크씩 끊어서 촬영하고 그것을 이어붙여서 
//하나의 영화를 만들게 되는데 그 한 테이크를 씬이라고 한다. 게임도 이와 마찬가지로 하나의 씬으로만 처음부터 끝까지 쭉 이어 만드는 것이 아닌 여러 씬을 만들고 그것을 
//이어붙이는 과정이 있게 된다.
//간단하게 가장 유명한 게임인 리그 오브 레전드(약칭 롤)를 예시로 들자면 롤 클라이언트를 키게 되면 로그인 화면이 나오게 되고 로그인을 하면 메인 창이 뜨게 되고 게임을
//선택해서 매칭을 잡으면 픽창으로 넘어가게 되고 거기서 챔피언을 고르면 실제 게임 화면으로 넘어가 플레이하게 되고 끝나면 여러 정보를 보여주는데 그것을 씬으로 묶어보면 아래와 같이 된다.
//로그인 창 -> 메인 화면 -> 픽창 -> 게임 로딩 창 -> 게임 플레이 창 -> 게임 종료 후 점수 등의 정보 창
//이것들 하나 하나가 씬이고 한 게임은 여러 씬으로 구성된다는 것을 알 수 있다. 이것을 씬 구조라고 한다.(유니티에서는 씬, 언리얼에서는 레벨이라고 칭한다.)
//씬 하나에 수많은 오브젝트들이 있을 것이기 때문에 이들을 관리하고 코드가 길어지는 것을 방지하기 위해서라도 배열이 필요하고 그러기 위해 오브젝트를 벡터로 묶어놓는 것이다.
//씬이 하나만 있는 것도 아니고 씬 안에 동일한 오브젝트들만 들어가는 것도 아니기 때문에 이런 씬을 만들기 위한 것들이 필요하다.

namespace mfe {
	//씬 관련 작업 수행
	//씬은 여러 개를 만들기 때문에 디버깅 시에 구분해야 할 필요가 있어 Entity 클래스를 상속받아서 조금 더 쉽게 구분할 수 있게 한다.
	//Entity 클래스를 상속받음으로써 씬들마다 각자의 이름을 가지게 되서 디버깅 시 구분이 쉬워질 것이다.
	class Scene : public Entity
	{
	private:
		//씬 하나에 여러 오브젝트들이 있을 것이기 때문에 vector(배열)로 갖고 있게 되는 것이다.
		//std::vector<GameObject*> mGameObjects;  //Layer 클래스로 옮김
		std::vector<Layer*> mLayers;  //오브젝트는 레이어가 관리하고 그 레이어들은 씬에서 관리(레이어는 씬을 구성하는 조각)

	public:
		Scene();

		//가상 함수로 해야 하는 이유는 이 클래스가 상속 관계를 가지기 때문이다.
		//상속 관계가 생기면 특이한 점이 자식 클래스 객체의 타입을 부모 클래스로 지정할 수 있다는 것이다.
		//그렇기 때문에 가상 함수가 필요한 것인데 만약 부모 클래스에서 정의한 함수와 자식 클래스에서 정의한 함수가 다른 경우에 자식 클래스는 자신이 정의한 함수를 가져와야 문제가
		//생기지 않는데 부모 클래스에서 정의한 함수가 호출되어서 원하는 결과를 추출하지 못하는 문제가 발생할 수 있다. 그래서 가상 함수가 필요한 것이다.
		//가상 함수로 선언하면 오버라이딩한 함수를 호출하기 때문에 부모 클래스는 부모 클래스에서 정의한 함수를 자식 클래스는 함수 오버라이딩한 자식 클래스의 함수를 사용할 수 있게 되기 때문이다.
		virtual void Initialize();
		virtual void Update();
		virtual void LateUpdate();
		virtual void Render(HDC hdc);

		//씬이 바뀔 때마다 호출해줄 수 있는 함수의 구조를 만듦
		//씬을 전환할 때 필요한 동작들이 있기에 이를 해줄 역할을 하는 함수들을 만들어야 한다.(한 씬에는 없는 몬스터가 다른 씬에는 있는 경우같이 전환할 때 필요한 동작들이 있다.)
		virtual void OnEnter();  //기존 씬에서 씬을 전환할 때 전환하는 씬에 필요한 동작을 정의
		virtual void OnExit();  //전환하면서 기존 씬에 필요한 동작을 정의

		//void AddGameObject(GameObject* gameObject);  //이 동작도 오브젝트와 관련이 있기에 레이어로 옮긴다.
		void AddGameObject(GameObject* gameObject, const eLayerType type);  //기존 함수와 달리 어느 레이어에 오브젝트를 추가할 것인지를 인자로 받는다.

		~Scene();
	};
}