#pragma once
#include "mfeEntity.h"

namespace mfe {
	class Resource abstract : public Entity  //추상 클래스(순수 가상 함수가 하나 이상 포함된 클래스) - 메모리 할당 불가(상속받아서만 사용해야 한다.)
	{
	private:
		std::wstring mPath;  //리소스의 경로(리소스는 사용할 리소스의 이름은 물론이고 경로 또한 알고 있어야 한다.)
		const enums::eResourceType mType;  //리소스 타입

	public:
		//상속을 해줄 클래스이기 때문에 함수들은 가상 함수로 만들어준다.
		//무조건 타입을 받아야 하기 때문에 생성자에서 리소스 타입을 받는다.(디폴트 생성자는 사용할 수 없어야 한다.
		Resource(enums::eResourceType type);  //생성자는 딱 한 번만 호출되고 자기 자신만 볼 수 있기 때문에 가상 함수로 만들 수 없어서 virtual 키워드 사용이 불가능하다.

		//순수 가상 함수(실제 메모리 할당이 불가능해지는 문법)
		//선언한 파일에서는 구현부가 필요없다. 대신 자식 클래스에서는 반드시 재정의
		virtual HRESULT Load(const std::wstring& path) = 0;  //리소스를 불러오는 함수(리소스는 불러와서 메모리 영역에 올려오는 것이기 때문에 리소스 경로를 받아 올려주어야 한다.)
		//HRESULT는 0보다 크면 참을 반환한다고 되어 있는데 말 그대로 bool타입과 동일하다는 것을 알 수 있다. 그러면 bool을 쓰면 되지 않나라는 생각이 들게 될텐데 윈도우와 관련된 프로그램의
		//함수는 HRESULT를 반환하기 때문에 이와 같이 HRESULT를 사용하게 된다.(윈도우 자체에서 편하게 사용하기 위해 사용)
		//HRESULT에는 TRUE(1), FALSE(0) 값을 넣을 수 있다.(기존 bool의 true, false와는 차별화된 모습이다.)

		const std::wstring& GetPath() {
			return mPath;
		}

		//매개 변수로 참조를 쓰는 이유는 일반 변수라면 문자열 복사이기 때문에 한 글자씩 배열로 넘길텐데 참조는 원본을 그대로 넘기기 때문에 포인터 정도의 크기만 사용하게 된다.
		//다른 문자열 인자를 받는 함수들도 같은 이유로 참조를 쓴다.
		void SetPath(const std::wstring& path) {  
			mPath = path;
		}

		virtual ~Resource();  //소멸자는 이와 관계가 없어서 virtual 선언이 가능하다.
	};

	//아래와 같이 리소스 관련 클래스들은 모두 Resource 클래스를 상속받아 만들어지게 될 것이다.
	//다른 의미로는 Resource 클래스의 객체를 만들어 메모리를 할당받을 일은 없을 것이다. 그렇기에 Resource 클래스는 추상 클래스로 만들어야 한다.
	//추상 클래스는 말 그대로 객체를 할당하지 않도록 막아놓은 클래스를 말한다. 
	//추상 클래스를 만드는 방법은 아주 간단한데 바로 가상 함수를 순수 가상 함수로 만들기만 하면 클래스 객체 할당이 불가능하게 되면서 추상 클래스로 만들어진다.
	//순수 가상 함수란 자식 클래스에서 반드시 재정의해야 하는 멤버 함수를 의미하는데 가상 함수는 반드시 자식 클래스가 재정의할 필요는 없는데 순수 가상 함수는 반드시 자식 클래스에서
	//재정의를 해주어야만 한다. 순수 가상 함수를 만드는 법은 간단한데 가상 함수를 선언할 때 '= 0;'을 붙이기만 하면 된다.(예시는 바로 위의 순수 가상 함수를 보면 된다.)
	//즉, 추상 클래스는 순수 가상 함수를 하나 이상 포함하는 클래스이다.
	//그러니 순수 가상 함수를 사용하였다는 것은 반드시 해당 클래스를 상속받아서 사용하여야 한다는 것을 의미한다.
	//class Texture : public Resource
	//class AudioClip : public Resource
}